#Java设计模式及常见问题梳理总结

##单例设计模式总结
知识重点:
    1.私有化构造器
    2.保证线程安全
    3.延迟加载
    4.防止序列化和反序列化破坏单例
    5.防止反射攻击破坏单例

单例的优点:
    1.在内存中只有一个实例,减少了内存开销
    2.可以避免对资源的多重占用
    3.设置全局访问点,严格控制访问

单例的缺点:
    1.没有接口,扩展困难
    2.如果要扩展单例对象,只能修改代码没有其他途径(不符合开闭原则)
    
    
##原型模式(构建型)
适用场景:
    1.类初始化消耗资源过多
    2.new产生对象过程非常繁琐(数据准备,访问权限等)
    3.构造函数比较复杂
    4.循环体中产生大量对象导致可读性下降时
    
成熟案例:
    BeanUtils.copy(),JSON.parseObject(),Guava...    
  
总结:
    是快速构建对象的方法总结,(1)简单工厂将getter,setter封装到某个方法中,(2)JDK提供实现Cloneable接口进行快速复制
    Spring中一般都是浅克隆,原型模式与单例模式存在本质上的冲突(如果必须实现共存可以通过实现io中readResolve方法等处理)
    
缺点:
    1.必须配备克隆(或者可拷贝)方法
    2.对克隆复杂对象或丢克隆对象进行复杂改造时易带来风险
    3.深拷贝,浅拷贝要运用得当
    
    
##代理模式(结构型)
   1.为其他对象提供一种代理以控制对这个对象的访问(保护对象,增强对象)
   2.代理对象在客服端和目标对象间起到中介作用
    
原理:
    JDK动态代理:
        1.拿到被代理类(必须实现接口)的引用,并且获取它的所有接口(反射获取)
        2.JDK Proxy类重新生成一个新的类,实现了被代理类所有接口的方法
        3.动态生成Java代码,把增强逻辑加入到新生成代码中
        4.编译生成新的Java代码的class文件
        5.加载并运行新的class,得到的类就是全新生成的类(代理类"$Proxy0",序号可自增)
    
    CGLib代理:
        

实例:
    Spring框架中AOP实现
    
思考:
    代理模式应用场景及实现原理(实现数据源动态切换),
    静态代理和动态代理的区别(静态需显示声明--但不符合开闭原则,动态代理则是动态配置和替换被代理对象),
    CGLib和JDK Proxy的根本区别(cglib方式可以直接生成,但jdk方式需实现接口)
    
    
##查疑补缺记录
    1.总结内部类执行逻辑
    2.单例中实现ObjectInputStream反射调用readResolve方法以保证单例不被序列化破坏的原理及流程
    3.后续需补充序列化及反序列化对单例破坏的用例
    4.后续补充发令枪多线程测试类
    5.理解枚举单例中防范序列化及反射破坏单例的实现原理(借助jad反编译源码,javap用于反编译字节码,需区分清楚)
    