#Java设计模式及常见问题梳理总结

##单例设计模式总结
知识重点:
    1.私有化构造器
    2.保证线程安全
    3.延迟加载
    4.防止序列化和反序列化破坏单例
    5.防止反射攻击破坏单例

单例的优点:
    1.在内存中只有一个实例,减少了内存开销
    2.可以避免对资源的多重占用
    3.设置全局访问点,严格控制访问

单例的缺点:
    1.没有接口,扩展困难
    2.如果要扩展单例对象,只能修改代码没有其他途径(不符合开闭原则)
    
    
##原型模式(构建型)
适用场景:
    1.类初始化消耗资源过多
    2.new产生对象过程非常繁琐(数据准备,访问权限等)
    3.构造函数比较复杂
    4.循环体中产生大量对象导致可读性下降时
    
成熟案例:
    BeanUtils.copy(),JSON.parseObject(),Guava...    
  
总结:
    是快速构建对象的方法总结,(1)简单工厂将getter,setter封装到某个方法中,(2)JDK提供实现Cloneable接口进行快速复制
    Spring中一般都是浅克隆,原型模式与单例模式存在本质上的冲突(如果必须实现共存可以通过实现io中readResolve方法等处理)
    
缺点:
    1.必须配备克隆(或者可拷贝)方法
    2.对克隆复杂对象或丢克隆对象进行复杂改造时易带来风险
    3.深拷贝,浅拷贝要运用得当
    
    
##代理模式(结构型)
优点:
   1.为其他对象提供一种代理以控制对这个对象的访问(保护对象,增强对象)
   2.代理对象在客服端和目标对象间起到中介作用(隔离)
   3.一定程度上降低了系统的耦合程度,易于拓展
   
缺点:
    1.会造成系统设计中类的数目增加
    2.在客户端和目标对象间增加了代理对象,会造成请求处理速度变慢
    3.增加了系统复杂度
    
原理:
    JDK动态代理:
        1.拿到被代理类(必须实现接口)的引用,并且获取它的所有接口(反射获取)
        2.JDK Proxy类重新生成一个新的类,实现了被代理类所有接口的方法
        3.动态生成Java代码,把增强逻辑加入到新生成代码中
        4.编译生成新的Java代码的class文件
        5.加载并运行新的class,得到的类就是全新生成的类(代理类"$Proxy0",序号可自增)
    
    CGLib代理:
        使用ASM框架写Class字节码

实例:
    Spring框架中AOP实现
    
思考:
    代理模式应用场景及实现原理(实现数据源动态切换),
    静态代理和动态代理的区别(静态需显示声明--但不符合开闭原则,动态代理则是动态配置和替换被代理对象),
    CGLib和JDK Proxy的根本区别(cglib通过继承关系实现,而jdk方式需目标类实现接口)
        (1)cglib覆盖父类方法进行实现(任意普通类都可),生成逻辑  更复杂,效率和调用效率更高生成一个包含了所有逻辑的FaseClass,不需再反射调用(但不能代理final的方法)
        (2)JDK Proxy生成代理逻辑简单(直接写Class字节码),执行效率相对要低,每次都要反射动态调用
    为什么JDK代理中对接口总数限制在65535以下?(JVM在class文件定义时，规定interface的类型是u2，2个字节，16位，那么最多支持2的16次方-1，也就是65535,可参考: https://www.baidu.com/s?ie=UTF-8&wd=JVM%E5%9C%A8class%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E6%97%B6%EF%BC%8C%E8%A7%84%E5%AE%9Ainterface%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AFu2)
        

##委派模式(行为型)
    负责任务的调度和分配任务,可以看做一种特殊情况下的静态代理的全权代理,但代理模式注重过程,委派模式注重结果
    不属于GOF23种模式之一

实例:
    Spring中Delegate或Dispatcher在类中包含的都是委派模式


##策略模式()
    定义了算法家族,分别封装使之可以相互替换,此模式让算法的 变化不会影响到算法的用户(可以避免多重分支的if...else和switch语句)

实例:
    JDK中Comparator接口的compare()实现,Spring中IstantiationStrategy(选择jdk还是cglib实现类,单例还是多例...)

优点:
    1.符合开闭原则,避免了使用多重条件转移语句,如if...else...,switch语句等
    2.可以提高算法的保密性和安全性
    
缺点:
    1.客户端必须知道所有的策略,并且自行决定使用哪一个策略类
    2.代码中会产生非常多策略类,增加维护难度
    
    
    
    
    

    
##查疑补缺记录
    1.总结内部类执行逻辑
    2.单例中实现ObjectInputStream反射调用readResolve方法以保证单例不被序列化破坏的原理及流程
    3.后续需补充序列化及反序列化对单例破坏的用例
    4.后续补充发令枪多线程测试类
    5.理解枚举单例中防范序列化及反射破坏单例的实现原理(借助jad反编译源码,javap用于反编译字节码,需区分清楚)
    